package gov.cdc.prime.router

import com.github.doyaaaaaken.kotlincsv.dsl.csvReader
import com.github.doyaaaaaken.kotlincsv.dsl.csvWriter
import java.io.InputStream
import java.io.OutputStream

/**
 * A converter differs from a serialization in that
 */
class CsvConverter(val metadata: Metadata) {
    private data class CsvMapping(
        val useCsv: Map<String, Element.CsvField>,
        val useMapper: Map<String, Pair<Mapper, List<String>>>,
        val useDefault: Map<String, String>,
        val errors: List<String>,
        val warnings: List<String>,
    )

    private data class RowResult(
        val row: List<String>,
        val errors: List<String>,
        val warnings: List<String>,
    )

    data class ReadResult(
        /**
         * The report generated by the read may be empty because of read validation errors
         */
        val report: Report?,
        /**
         * The list of rows that were rejected while reading
         */
        val rejected: List<Int> = emptyList(),
        /**
         * The list of errors that caused a item to not be reported
         */
        val errors: List<String> = emptyList(),
        /**
         * An list of warnings that could be a data error
         */
        val warnings: List<String> = emptyList(),
    )

    fun read(schemaName: String, input: InputStream, source: Source): ReadResult {
        return read(schemaName, input, listOf(source))
    }

    fun read(
        schemaName: String,
        input: InputStream,
        sources: List<Source>,
        destination: OrganizationService? = null,
        defaultValues: Map<String, String> = emptyMap(),
    ): ReadResult {
        val schema = metadata.findSchema(schemaName) ?: error("Internal Error: invalid schema name '$schemaName'")
        val rows: List<Map<String, String>> = csvReader().readAllWithHeader(input)
        val rejected = mutableListOf<Int>()
        val errors = mutableListOf<String>()
        val warnings = mutableListOf<String>()

        if (rows.isEmpty()) {
            return ReadResult(Report(schema, emptyList(), sources, destination), rejected, errors, warnings)
        }

        val csvMapping = buildMappingForReading(schema, defaultValues, rows[0])
        errors.addAll(csvMapping.errors)
        warnings.addAll(csvMapping.warnings)
        if (csvMapping.errors.isNotEmpty()) {
            return ReadResult(null, rejected, errors, warnings)
        }

        val mappedRows = rows.mapIndexedNotNull { index, row ->
            val result = mapRow(schema, csvMapping, index, row)
            errors.addAll(result.errors)
            warnings.addAll(result.warnings)
            if (result.errors.isEmpty()) {
                result.row
            } else {
                rejected.add(index)
                null
            }
        }
        return ReadResult(Report(schema, mappedRows, sources, destination), rejected, errors, warnings)
    }

    fun write(report: Report, output: OutputStream) {
        val schema = report.schema

        fun buildHeader(): List<String> = schema.csvFields.map { it.name }

        fun buildRows(): List<List<String>> {
            return report.itemIndices.map { row ->
                schema
                    .elements
                    .flatMap { element ->
                        if (element.csvFields != null) {
                            element.csvFields.map { field ->
                                val value = report.getString(row, element.name)
                                    ?: error("Internal Error: table is missing '${element.name} column")
                                element.toFormatted(value, field.format)
                            }
                        } else {
                            emptyList()
                        }
                    }
            }
        }

        val allRows = listOf(buildHeader()).plus(buildRows())
        csvWriter {
            lineTerminator = "\n"
            outputLastLineTerminator = true
        }.writeAll(allRows, output)
    }

    private fun buildMappingForReading(
        schema: Schema,
        defaultValues: Map<String, String>,
        row: Map<String, String>
    ): CsvMapping {
        val useCsv = schema
            .elements
            .filter { it.csvFields != null && row.containsKey(it.csvFields.first().name) }
            .map { it.name to it.csvFields!!.first() } // TODO: be more flexible than first field
            .toMap()
        val useMapper = schema
            .elements
            .filter { it.mapper?.isNotBlank() == true } // TODO: check for the presence of fields
            .map { it.name to Pair(it.mapperRef!!, it.mapperArgs!!) }
            .toMap()
        val useDefault = schema
            .elements
            .map { it.name to it.defaultValue(defaultValues) }
            .toMap()

        // Figure out what is missing or ignored
        val requiredHeaders = schema.filterCsvFields(Element.Usage.REQUIRED).map { it.name }.toSet()
        val requestedHeaders = schema.filterCsvFields(Element.Usage.REQUESTED).map { it.name }.toSet()
        val optionalHeaders = schema.filterCsvFields(Element.Usage.OPTIONAL).map { it.name }.toSet()
        val actualHeaders = row.keys.toSet()
        val missingRequiredHeaders = requiredHeaders - actualHeaders
        val missingRequestedHeaders = requestedHeaders - actualHeaders
        val ignoredHeaders = actualHeaders - requestedHeaders - requiredHeaders - optionalHeaders
        val errors = missingRequiredHeaders.map { "Error: Missing required '$it' header" }
        val warnings =
            missingRequestedHeaders.map { "Warning: Missing requested '$it' header" } +
                ignoredHeaders.map { "Warning: Unexpected '$it' header is ignored" }

        return CsvMapping(useCsv, useMapper, useDefault, errors, warnings)
    }

    /**
     * For a input row from the CSV file map to a schema defined row by
     *  1. Using values from the csv file
     *  2. Using a mapper defined by the schema
     *  3. Using the default defined by the schema
     *
     * Also, format values into the normalized format for the type
     */
    private fun mapRow(schema: Schema, csvMapping: CsvMapping, index: Int, inputRow: Map<String, String>): RowResult {
        val lookupValues = mutableMapOf<String, String>()
        val errors = mutableListOf<String>()
        val warnings = mutableListOf<String>()

        val row = schema.elements.map { element ->
            fun addToLookup(normalized: String): String {
                lookupValues[element.name] = normalized
                return normalized
            }

            fun addDefaultValue(): String {
                val value = if (csvMapping.useDefault.containsKey(element.name))
                    csvMapping.useDefault.getValue(element.name)
                else
                    ""
                return addToLookup(value)
            }

            fun recordError(error: String) {
                return when (element.usageRequirement?.usage) {
                    Element.Usage.REQUIRED -> { errors += "Error: Invalid required value on row $index: $error" }
                    Element.Usage.REQUESTED -> { warnings += "Warning: Invalid requested value on row $index: $error" }
                    Element.Usage.REQUIRED_IF_PRESENT -> TODO()
                    Element.Usage.REQUIRED_IF_NOT_PRESENT -> TODO()
                    Element.Usage.OPTIONAL,
                    null -> { warnings += "Warning: Invalid optional value on row $index: $error" }
                }
            }

            fun checkValue(format: String?, value: String): Boolean {
                return element.checkForError(value, format)?.let {
                    recordError(it)
                    false
                } ?: true
            }

            when (element.name) {
                in csvMapping.useCsv -> {
                    val csvField = csvMapping.useCsv.getValue(element.name)
                    val value = inputRow.getValue(csvField.name)
                    if (checkValue(csvField.format, value)) {
                        val normalizedValue = element.toNormalized(value, csvField.format)
                        addToLookup(normalizedValue)
                    } else {
                        addToLookup("")
                    }
                }

                in csvMapping.useMapper -> {
                    val (mapper, args) = csvMapping.useMapper.getValue(element.name)
                    val valueNames = mapper.valueNames(element, args)
                    val valuesForMapper = valueNames.map { elementName ->
                        val valueElement = schema.findElement(elementName)
                            ?: error("Schema Error: Could not find element '$elementName' for mapper '${mapper.name}'")
                        val value = if (lookupValues.containsKey(elementName)) {
                            lookupValues.getValue(elementName)
                        } else {
                            recordError("Empty mapper input for $elementName")
                            ""
                        }
                        ElementAndValue(valueElement, value)
                    }
                    val value = mapper.apply(element, args, valuesForMapper)
                    if (value != null)
                        addToLookup(value)
                    else {
                        recordError("Empty mapper result for $element.name")
                        ""
                    }
                }

                in csvMapping.useDefault -> {
                    addDefaultValue()
                }

                else -> {
                    error("Internal Error: '${element.name}' does not have a CSV mapping. Should of been caught earlier.")
                }
            }
        }
        return RowResult(row, errors, warnings)
    }
}
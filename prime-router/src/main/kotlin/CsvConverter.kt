package gov.cdc.prime.router

import com.github.doyaaaaaken.kotlincsv.dsl.csvReader
import com.github.doyaaaaaken.kotlincsv.dsl.csvWriter
import java.io.InputStream
import java.io.OutputStream

/**
 * A converter differs from a serialization in that
 */
class CsvConverter(val metadata: Metadata) {
    private data class CsvMapping(
        val useCsv: Map<String, Element.CsvField>,
        val useMapper: Map<String, Pair<Mapper, List<String>>>,
        val useDefault: Map<String, String>,
        val errors: List<String>,
        val warnings: List<String>,
    )

    private data class RowResult(
        val row: List<String>,
        val errors: List<String>,
        val warnings: List<String>,
    )

    data class ReadResult(
        /**
         * The report generated by the read may be empty because of read validation errors
         */
        val report: Report?,
        /**
         * The list of rows that were rejected while reading
         */
        val rejected: List<Int> = emptyList(),
        /**
         * The list of errors that caused a item to not be reported
         */
        val errors: List<String> = emptyList(),
        /**
         * An list of warnings that could be a data error
         */
        val warnings: List<String> = emptyList(),
    )

    fun read(schemaName: String, input: InputStream, source: Source): ReadResult {
        return read(schemaName, input, listOf(source))
    }

    fun read(
        schemaName: String,
        input: InputStream,
        sources: List<Source>,
        destination: OrganizationService? = null,
        defaultValues: Map<String, String> = emptyMap(),
    ): ReadResult {
        val schema = metadata.findSchema(schemaName) ?: error("Internal Error: invalid schema name '$schemaName'")
        val rows: List<Map<String, String>> = csvReader().readAllWithHeader(input)
        val rejected = mutableListOf<Int>()
        val errors = mutableListOf<String>()
        val warnings = mutableListOf<String>()

        if (rows.isEmpty()) {
            return ReadResult(Report(schema, emptyList(), sources, destination), rejected, errors, warnings)
        }

        val csvMapping = buildMappingForReading(schema, defaultValues, rows[0])
        errors.addAll(csvMapping.errors)
        warnings.addAll(csvMapping.warnings)
        if (csvMapping.errors.isNotEmpty()) {
            return ReadResult(null, rejected, errors, warnings)
        }

        val mappedRows = rows.mapIndexedNotNull { index, row ->
            val result = mapRow(schema, csvMapping, index, row)
            errors.addAll(result.errors)
            warnings.addAll(result.warnings)
            if (result.errors.isEmpty()) {
                result.row
            } else {
                rejected.add(index)
                null
            }
        }
        return ReadResult(Report(schema, mappedRows, sources, destination), rejected, errors, warnings)
    }

    fun write(report: Report, output: OutputStream) {
        val schema = report.schema

        fun buildHeader(): List<String> = schema.csvFields.map { it.name }

        fun buildRows(): List<List<String>> {
            return report.itemIndices.map { row ->
                schema
                    .elements
                    .flatMap { element ->
                        if (element.csvFields != null) {
                            element.csvFields.map { field ->
                                val value = report.getString(row, element.name)
                                    ?: error("Internal Error: table is missing '${element.name} column")
                                element.toFormatted(value, field.format)
                            }
                        } else {
                            emptyList()
                        }
                    }
            }
        }

        val allRows = listOf(buildHeader()).plus(buildRows())
        csvWriter {
            lineTerminator = "\n"
            outputLastLineTerminator = true
        }.writeAll(allRows, output)
    }

    private fun buildMappingForReading(
        schema: Schema,
        defaultValues: Map<String, String>,
        row: Map<String, String>
    ): CsvMapping {
        val useCsv = schema
            .elements
            .filter { it.csvFields != null && row.containsKey(it.csvFields.first().name) }
            .map { it.name to it.csvFields!!.first() } // TODO: be more flexible than first field
            .toMap()
        val useMapper = schema
            .elements
            .filter { it.mapper?.isNotBlank() == true } // TODO: check for the presence of fields
            .map { it.name to Pair(it.mapperRef!!, it.mapperArgs!!) }
            .toMap()
        val useDefault = schema
            .elements
            .map { it.name to it.defaultValue(defaultValues) }
            .toMap()

        // Figure out what is missing or ignored
        val requiredHeaders = schema.filterCsvFields(Element.Usage.REQUIRED).map { it.name }.toSet()
        val requestedHeaders = schema.filterCsvFields(Element.Usage.REQUESTED).map { it.name }.toSet()
        val optionalHeaders = schema.filterCsvFields(Element.Usage.OPTIONAL).map { it.name }.toSet()
        val actualHeaders = row.keys.toSet()
        val missingRequiredHeaders = requiredHeaders - actualHeaders
        val missingRequestedHeaders = requestedHeaders - actualHeaders
        val ignoredHeaders = actualHeaders - requestedHeaders - requiredHeaders - optionalHeaders
        val errors = missingRequiredHeaders.map { "Error: Missing required '$it' header" }
        val warnings =
            missingRequestedHeaders.map { "Warning: Missing requested '$it' header" } +
                ignoredHeaders.map { "Warning: Unexpected '$it' header is ignored" }

        return CsvMapping(useCsv, useMapper, useDefault, errors, warnings)
    }

    /**
     * For a input row from the CSV file map to a schema defined row by
     *
     *  1. Using values from the csv file
     *  2. Using a mapper defined by the schema
     *  3. Using the default defined by the schema
     *
     * If the element `canBeBlank` then only step 1 is used.
     *
     * Also, format values into the normalized format for the type
     */
    private fun mapRow(schema: Schema, csvMapping: CsvMapping, index: Int, inputRow: Map<String, String>): RowResult {
        val lookupValues = mutableMapOf<String, String>()
        val errors = mutableListOf<String>()
        val warnings = mutableListOf<String>()

        val row = schema.elements.map { element ->
            fun addToLookup(normalized: String): String {
                lookupValues[element.name] = normalized
                return normalized
            }

            fun recordError(error: String) {
                return when (element.usageRequirement?.usage) {
                    Element.Usage.REQUIRED -> { errors += "Error: Invalid required value on item $index: $error" }
                    Element.Usage.REQUESTED -> { warnings += "Warning: Invalid requested value on item ${index + 1}: $error" }
                    Element.Usage.REQUIRED_IF_PRESENT -> TODO()
                    Element.Usage.REQUIRED_IF_NOT_PRESENT -> TODO()
                    Element.Usage.OPTIONAL,
                    null -> { warnings += "Warning: Invalid optional value on item ${index + 1}: $error" }
                }
            }

            fun useCsv(): String? {
                val csvField = csvMapping.useCsv[element.name] ?: return null
                val value = inputRow.getValue(csvField.name)
                if (value.isBlank()) return if (element.canBeBlank == true) "" else null
                val error = element.checkForError(value, csvField.format)
                if (error != null) {
                    recordError(error)
                    return ""
                }
                return element.toNormalized(value, csvField.format)
            }

            fun useMapper(): String? {
                val (mapper, args) = csvMapping.useMapper[element.name] ?: return null
                val valueNames = mapper.valueNames(element, args)
                val valuesForMapper = valueNames.map { elementName ->
                    val valueElement = schema.findElement(elementName)
                        ?: error("Schema Error: Could not find element '$elementName' for mapper '${mapper.name}'")
                    val value = lookupValues[elementName]
                        ?: error("Schema Error: No mapper input for $elementName")
                    ElementAndValue(valueElement, value)
                }
                return mapper.apply(element, args, valuesForMapper)
            }

            fun useDefault(): String {
                return csvMapping.useDefault[element.name] ?: ""
            }

            val value = useCsv() ?: useMapper() ?: useDefault()
            addToLookup(value)
            if (value.isBlank() &&
                element.canBeBlank != true &&
                element.usageRequirement?.usage != Element.Usage.OPTIONAL &&
                element.name in csvMapping.useCsv // Don't warn again if the header already has warned about this
            ) {
                recordError("Blank value for element '${element.name}'")
            }
            value
        }
        return RowResult(row, errors, warnings)
    }
}